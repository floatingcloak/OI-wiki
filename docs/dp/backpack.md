在学习本章前请确认你已经学习了[动态规划部分简介](/dp/)

在具体讲何为 "背包 dp" 前，先来看如下的例题

??? note " 例题[\[USACO07DEC\]手链 Charm Bracelet](https://www.luogu.org/problemnew/show/P2871)"
    本题题意可概括为——N 物体，放入容量为 M 的背包，要求使总价值最大。由于每个物体只有 2 种情况——取与不取，正如二进制中的 0 和 1——这类问题便被称为“0-1 背包问题”。

## 0-1 背包

例题中已知条件有第 i 个物体的体积 v[i]和价值 w[i], 背包总容量

显而易见的是，可以计算总价值的，只有已经放入背包的物体，因此该题中对 "是否为最大值" 的判断是建立在 "已经放入背包之中" 的基础之上的

已知对于一个容量为 v1，可以放置第 1 到第 i 件物体的背包，其最大总价值很明显等于容量为 v1 的背包，放有第 1 到第 (i-1) 件物体时的最大值（第 i 件物体不取时）或者是容量为 v1-v[i]的背包，放有第 1 到第 (i-1) 件物体时的最大值 + w[i](第i件物体取时)

由此可以得出状态转移方程

-   dp[v1][i]=max(dp[v1][i-1],dp[v1-v\[i\]][i-1]+w[i])

有了这样的思路，就可以顺利地写出代码了

```cpp
for (int i = 1; i <= v1; i++)
  for (it l = 0; l <= v1 - i; l++) dp[l + i] = max(dp[l] + w[i], dp[l + i]);
```

按照正确的思路，写出了这样的核心代码，然后就可以提交……

错！

让我们再回头看一下代码，i 表示当前判断的是第 i 个物体，l 则穷举体积，可是注意一个地方——l 是从 0 到 v1-v[i]

这意味着什么呢？举个栗子，可能在体积为 (l) 处取物体 i 新的 dp 值存到体积为 (l+v[i]) 处，而在体积为 (l+v[i]) 处，物体 i 再次被取

所以，当以 0~v1-v[i]的顺序穷举时，物体实际上可能被加入多遍，这显然与题意不符

因此为了避免多取，穷举顺序应为 v1-v[i]~0

因此实际核心代码为

```cpp
for (int i = 1; i <= v1; i++)
  for (int l = v1 - i; l >= 0; l--) dp[l + i] = max(dp[l] + w[i], dp[l + i]);
```

例题代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 13010;
int n, v, c[maxn], w[maxn], most[maxn];
int main() {
  cin >> n >> v;
  for (int i = 1; i <= n; i++) {
    cin >> c[i] >> w[i];
  }
  for (int i = 1; i <= n; i++)
    for (int l = v; l >= c[i]; l--) {
      if (most[l - c[i]] + w[i] > most[l]) most[l] = most[l - c[i]] + w[i];
    }
  cout << most[v];
  return 0;
}
```

Ps. 事实上，由小到大穷举是另一种背包问题的解法，稍后会提到

## 完全背包


## 多重背包
